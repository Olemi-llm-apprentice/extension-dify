async function extractPageContent() {
  const title = document.title;
  let content = '';
  let extractMethod = '';
  
  // YouTubeãƒšãƒ¼ã‚¸ã§ã®å­—å¹•å–å¾—ã‚’å„ªå…ˆ
  if (window.location.hostname === 'www.youtube.com' && window.location.pathname === '/watch') {
    console.log('ğŸ” [Dify Extension] YouTube video detected, attempting subtitle extraction');
    const subtitleResult = await extractYouTubeSubtitles();
    if (subtitleResult && subtitleResult.transcript) {
      content = subtitleResult.transcript;
      extractMethod = `YouTubeå­—å¹•ã‹ã‚‰æŠ½å‡ºï¼ˆ${subtitleResult.language}ï¼‰${subtitleResult.isAutoGenerated ? ' - è‡ªå‹•ç”Ÿæˆ' : ' - æ‰‹å‹•ä½œæˆ'}`;
      
      return {
        title,
        content: content.trim(),
        url: window.location.href,
        extractMethod,
        contentLength: content.trim().length
      };
    }
    console.log('ğŸ” [Dify Extension] YouTube subtitle extraction failed, falling back to default method');
  }
  
  // ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ¬ã‚¯ã‚¿ã®è¨­å®šã‚’ç¢ºèª
  const { extractSelectors } = await chrome.storage.sync.get(['extractSelectors']);
  
  if (extractSelectors && extractSelectors.trim()) {
    // ä¸Šç´šè€…è¨­å®š: ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ä½¿ç”¨
    const customSelectors = extractSelectors.split(',').map(s => s.trim());
    for (const selector of customSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element) {
          content = element.innerText;
          extractMethod = `ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ¬ã‚¯ã‚¿ã€Œ${selector}ã€ã‹ã‚‰æŠ½å‡º`;
          break;
        }
      } catch (error) {
        console.warn('Invalid selector:', selector);
      }
    }
  }
  
  if (!content) {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š: bodyå…¨ä½“ã‹ã‚‰å–å¾—ï¼ˆä¸è¦ãªè¦ç´ ã‚’é™¤å¤–ï¼‰
    const bodyClone = document.body.cloneNode(true);
    
    // ä¸è¦ãªè¦ç´ ã‚’å‰Šé™¤
    const unwantedSelectors = [
      'script', 'style', 'noscript', 'iframe', 'object', 'embed',
      'header', 'nav', 'footer', 'aside', '.advertisement', '.ads',
      '.social-share', '.comments', '.sidebar', '.menu', '.navigation',
      '[class*="ad-"]', '[id*="ad-"]', '[class*="advertisement"]',
      '[class*="social"]', '[class*="share"]', '[class*="comment"]',
      '.cookie-notice', '.popup', '.modal', '.overlay',
      '#dify-floating-button' // è‡ªèº«ã®ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒœã‚¿ãƒ³ã‚’é™¤å¤–
    ];
    
    unwantedSelectors.forEach(selector => {
      try {
        const elements = bodyClone.querySelectorAll(selector);
        elements.forEach(el => el.remove());
      } catch (error) {
        console.warn('Selector removal failed:', selector);
      }
    });
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
    content = bodyClone.innerText || bodyClone.textContent || '';
    
    // ç©ºè¡Œã®é™¤å»ã¨æ•´ç†
    content = content
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0)
      .join('\n')
      .replace(/\n{3,}/g, '\n\n'); // 3ã¤ä»¥ä¸Šã®é€£ç¶šæ”¹è¡Œã‚’2ã¤ã«
    
    extractMethod = 'bodyå…¨ä½“ã‹ã‚‰æŠ½å‡ºï¼ˆä¸è¦è¦ç´ é™¤å¤–æ¸ˆã¿ï¼‰';
  }
  
  return {
    title,
    content: content.trim(),
    url: window.location.href,
    extractMethod,
    contentLength: content.trim().length
  };
}

// YouTubeå­—å¹•æŠ½å‡ºæ©Ÿèƒ½
async function extractYouTubeSubtitles() {
  try {
    console.log('ğŸ” [Dify Extension] Starting YouTube subtitle extraction');
    
    // ytInitialPlayerResponseã®å–å¾—ã‚’è©¦è¡Œ
    let playerResponse = window.ytInitialPlayerResponse;
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãŒåˆ©ç”¨ã§ããªã„å ´åˆã¯HTMLã‹ã‚‰æŠ½å‡º
    if (!playerResponse) {
      try {
        const scriptTags = document.querySelectorAll('script');
        for (const script of scriptTags) {
          if (script.textContent.includes('ytInitialPlayerResponse')) {
            const match = script.textContent.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
            if (match) {
              playerResponse = JSON.parse(match[1]);
              break;
            }
          }
        }
      } catch (error) {
        console.error('ğŸ” [Dify Extension] ytInitialPlayerResponse parsing error:', error);
        return null;
      }
    }
    
    if (!playerResponse) {
      console.log('ğŸ” [Dify Extension] ytInitialPlayerResponse not found');
      return null;
    }
    
    // å­—å¹•ãƒˆãƒ©ãƒƒã‚¯ã®ç¢ºèª
    const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    if (!captionTracks || captionTracks.length === 0) {
      console.log('ğŸ” [Dify Extension] No subtitle tracks available');
      return null;
    }
    
    console.log('ğŸ” [Dify Extension] Found', captionTracks.length, 'subtitle tracks');
    
    // å„ªå…ˆè¨€èªé †ã§å­—å¹•ã‚’å–å¾—ï¼ˆæ—¥æœ¬èª > è‹±èª > ãã®ä»–ï¼‰
    const preferredLanguages = ['ja', 'en'];
    let selectedTrack = null;
    
    // ã¾ãšæ‰‹å‹•ä½œæˆå­—å¹•ã‚’æ¢ã™
    for (const lang of preferredLanguages) {
      selectedTrack = captionTracks.find(track => 
        track.languageCode === lang && !track.vssId.includes('.a.')
      );
      if (selectedTrack) {
        console.log('ğŸ” [Dify Extension] Found manual subtitle in', lang);
        break;
      }
    }
    
    // æ‰‹å‹•å­—å¹•ãŒãªã„å ´åˆã¯è‡ªå‹•ç”Ÿæˆå­—å¹•ã‚’ä½¿ç”¨
    if (!selectedTrack) {
      for (const lang of preferredLanguages) {
        selectedTrack = captionTracks.find(track => 
          track.languageCode === lang && track.vssId.includes('.a.')
        );
        if (selectedTrack) {
          console.log('ğŸ” [Dify Extension] Found auto-generated subtitle in', lang);
          break;
        }
      }
    }
    
    // ã©ã¡ã‚‰ã‚‚ãªã„å ´åˆã¯æœ€åˆã®ãƒˆãƒ©ãƒƒã‚¯ã‚’ä½¿ç”¨
    if (!selectedTrack) {
      selectedTrack = captionTracks[0];
      console.log('ğŸ” [Dify Extension] Using first available subtitle track');
    }
    
    if (!selectedTrack || !selectedTrack.baseUrl) {
      console.log('ğŸ” [Dify Extension] No suitable subtitle track found');
      return null;
    }
    
    // å­—å¹•ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
    try {
      console.log('ğŸ” [Dify Extension] Fetching subtitle data from:', selectedTrack.baseUrl);
      const response = await fetch(selectedTrack.baseUrl + '&fmt=json3');
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const captionData = await response.json();
      console.log('ğŸ” [Dify Extension] Subtitle data fetched successfully');
      
      // å­—å¹•ãƒ†ã‚­ã‚¹ãƒˆã®æ•´å½¢
      const transcript = processYouTubeTranscript(captionData);
      
      if (!transcript || transcript.length < 10) {
        console.log('ğŸ” [Dify Extension] Transcript too short or empty');
        return null;
      }
      
      return {
        language: selectedTrack.languageCode,
        languageName: selectedTrack.name?.simpleText || selectedTrack.languageCode,
        isAutoGenerated: selectedTrack.vssId.includes('.a.'),
        transcript: transcript
      };
      
    } catch (fetchError) {
      console.error('ğŸ” [Dify Extension] Failed to fetch subtitle data:', fetchError);
      return null;
    }
    
  } catch (error) {
    console.error('ğŸ” [Dify Extension] YouTube subtitle extraction error:', error);
    return null;
  }
}

// YouTubeå­—å¹•ãƒ‡ãƒ¼ã‚¿ã®æ•´å½¢å‡¦ç†
function processYouTubeTranscript(captionData) {
  try {
    if (!captionData || !captionData.events) {
      return '';
    }
    
    const transcriptSegments = [];
    let currentParagraph = [];
    let lastEndTime = 0;
    
    captionData.events
      .filter(event => event.segs && event.segs.length > 0)
      .forEach(event => {
        const text = event.segs
          .map(seg => seg.utf8 || '')
          .join('')
          .trim();
          
        if (text) {
          const startTimeMs = event.tStartMs || 0;
          const durationMs = event.dDurationMs || 0;
          
          // 5ç§’ä»¥ä¸Šã®é–“éš”ãŒç©ºã„ãŸå ´åˆã¯æ®µè½ã‚’åˆ†ã‘ã‚‹
          if (startTimeMs - lastEndTime > 5000 && currentParagraph.length > 0) {
            transcriptSegments.push(currentParagraph.join(' '));
            currentParagraph = [];
          }
          
          currentParagraph.push(text);
          lastEndTime = startTimeMs + durationMs;
        }
      });
    
    // æœ€å¾Œã®æ®µè½ã‚’è¿½åŠ 
    if (currentParagraph.length > 0) {
      transcriptSegments.push(currentParagraph.join(' '));
    }
    
    // æ®µè½ã‚’æ”¹è¡Œã§çµåˆã—ã€èª­ã¿ã‚„ã™ã„å½¢å¼ã«ã™ã‚‹
    return transcriptSegments
      .filter(segment => segment.trim().length > 0)
      .join('\n\n')
      .replace(/\s+/g, ' ') // è¤‡æ•°ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’1ã¤ã«
      .trim();
    
  } catch (error) {
    console.error('ğŸ” [Dify Extension] Error processing transcript:', error);
    return '';
  }
}

// æ™‚é–“ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆãƒŸãƒªç§’ â†’ mm:sså½¢å¼ï¼‰
function formatTime(milliseconds) {
  const totalSeconds = Math.floor(milliseconds / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('ğŸ” [Dify Extension] Content script received message:', request);
  if (request.action === 'extractContent') {
    console.log('ğŸ” [Dify Extension] Starting content extraction in content script');
    extractPageContent().then(pageData => {
      console.log('ğŸ” [Dify Extension] Content extraction completed:', {
        title: pageData.title,
        contentLength: pageData.contentLength,
        extractMethod: pageData.extractMethod
      });
      sendResponse(pageData);
    }).catch(error => {
      console.error('ğŸ” [Dify Extension] Content extraction failed:', error);
      sendResponse({ error: error.message });
    });
    return true; // éåŒæœŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç¤ºã™
  }
});

function createFloatingButton() {
  const button = document.createElement('div');
  button.id = 'dify-floating-button';
  button.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    background: #4f46e5;
    border-radius: 50%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    cursor: move;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 24px;
    transition: transform 0.2s ease;
    user-select: none;
  `;
  button.innerHTML = 'ğŸ’¬';
  
  let isDragging = false;
  let dragStartX = null;
  let dragStartY = null;
  let buttonStartX = 0;
  let buttonStartY = 0;
  
  function getButtonPosition() {
    const rect = button.getBoundingClientRect();
    return {
      x: rect.left,
      y: rect.top
    };
  }
  
  function setButtonPosition(x, y) {
    const maxX = window.innerWidth - 60;
    const maxY = window.innerHeight - 60;
    
    x = Math.max(0, Math.min(x, maxX));
    y = Math.max(0, Math.min(y, maxY));
    
    button.style.left = x + 'px';
    button.style.top = y + 'px';
    button.style.right = 'auto';
    button.style.bottom = 'auto';
  }
  
  // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ«ã‚’é–‹ãï¼‰
  const clickHandler = () => {
    console.log('ğŸ” [Dify Extension] Floating button clicked, opening side panel');
    chrome.runtime.sendMessage({ action: 'openSidePanel' });
  };
  
  button.addEventListener('mousedown', (e) => {
    isDragging = false;
    
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    const pos = getButtonPosition();
    buttonStartX = pos.x;
    buttonStartY = pos.y;
    
    button.style.cursor = 'grabbing';
    button.style.transition = 'none';
    e.preventDefault();
  });
  
  document.addEventListener('mousemove', (e) => {
    if (dragStartX === null) return;
    
    const deltaX = e.clientX - dragStartX;
    const deltaY = e.clientY - dragStartY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    if (distance > 5 && !isDragging) {
      isDragging = true;
    }
    
    if (isDragging) {
      setButtonPosition(buttonStartX + deltaX, buttonStartY + deltaY);
    }
  });
  
  document.addEventListener('mouseup', (e) => {
    if (dragStartX === null) return;
    
    const deltaX = Math.abs(e.clientX - dragStartX);
    const deltaY = Math.abs(e.clientY - dragStartY);
    
    if (!isDragging && deltaX < 5 && deltaY < 5) {
      clickHandler();
    }
    
    isDragging = false;
    dragStartX = null;
    dragStartY = null;
    button.style.cursor = 'move';
    button.style.transition = 'transform 0.2s ease';
  });
  
  button.addEventListener('mouseenter', () => {
    if (!isDragging) {
      button.style.transform = 'scale(1.1)';
    }
  });
  
  button.addEventListener('mouseleave', () => {
    if (!isDragging) {
      button.style.transform = 'scale(1)';
    }
  });
  
  document.body.appendChild(button);
}

chrome.storage.sync.get(['isEnabled', 'blacklist'], (result) => {
  console.log('ğŸ” [Dify Extension] Storage check result:', result);
  
  // æ‹¡å¼µæ©Ÿèƒ½ãŒç„¡åŠ¹ãªå ´åˆã¯ãƒœã‚¿ãƒ³ã‚’ä½œæˆã—ãªã„
  if (result.isEnabled === false) {
    console.log('ğŸ” [Dify Extension] Extension is disabled, not creating button');
    return;
  }
  
  // ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
  const hostname = window.location.hostname;
  const blacklist = result.blacklist || [];
  
  if (blacklist.includes(hostname)) {
    console.log('ğŸ” [Dify Extension] Site is blacklisted, not creating floating button:', hostname);
    return;
  }
  
  console.log('ğŸ” [Dify Extension] Creating floating button');
  createFloatingButton();
});

window.addEventListener('load', () => {
  console.log('ğŸ” [Dify Extension] Page loaded, checking for button');
  const existingButton = document.getElementById('dify-floating-button');
  if (!existingButton) {
    console.log('ğŸ” [Dify Extension] Button not found, recreating');
    chrome.storage.sync.get(['isEnabled', 'blacklist'], (result) => {
      // æ‹¡å¼µæ©Ÿèƒ½ãŒç„¡åŠ¹ãªå ´åˆã¯ãƒœã‚¿ãƒ³ã‚’ä½œæˆã—ãªã„
      if (result.isEnabled === false) {
        return;
      }
      
      // ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
      const hostname = window.location.hostname;
      const blacklist = result.blacklist || [];
      
      if (blacklist.includes(hostname)) {
        console.log('ğŸ” [Dify Extension] Site is blacklisted, not recreating floating button:', hostname);
        return;
      }
      
      createFloatingButton();
    });
  }
});